#include "ModelBase.h"
#include "Windows.h"
#include "Tools/MapToJson/MapToJson.h"

ModelBase::ModelBase()
{
	_isInit = false;
	_isReadScenario = false;
}

ModelBase::~ModelBase()
{
	/*for (int i = 0; i < _myComponents.size(); i++)
	{
		delete _myComponents[i];
	}*/
	UnmapViewOfFile(pData);
	CloseHandle(hMapFile);
}

void ModelBase::Init(TiXmlElement* unitElement)
{
	if (unitElement == nullptr)
	{
		//没有找到XML节点，无法进行初始化,后面加入日志服务
		return;
	}
	int id = 0;
	GetIDFromTiXmlElement(id, unitElement);
	if (id == 0)
	{
		//模型没有设置ID，无法进行初始化,后面加入日志服务
		return;
	}
	_shareMemoryID = "_SM_" + to_string(id);
	SMStruct sm;
	Model_BasicInfo basicInfo;
	basicInfo._id = id;
	GetCampFromTiXmlElement(basicInfo._camp, unitElement);
	basicInfo._health = 100;
	string name;
	GetNameFromTiXmlElement(name, unitElement);
	strncpy_s(basicInfo._name, name.c_str(), sizeof(name) - 1);
	basicInfo._name[sizeof(name) - 1] = '\0'; // 确保终止符
	basicInfo._pos;
	std::vector<double> posVec;
	GetPositionFromTiXmlElement(posVec, unitElement);
	basicInfo._pos._lon = posVec[0];
	basicInfo._pos._lat = posVec[1];
	basicInfo._pos._alt = posVec[2];
	basicInfo._shape;
	basicInfo._type = 0;
	sm.basicInfo = basicInfo;
	CreateSmData(sm);
	_isInit = true;

}

void ModelBase::ReadScenario()
{
	_isReadScenario = true;
}

void ModelBase::PostEvent()
{
}

void ModelBase::SetHealth(double health)
{
	//_health = health;
	//1.通过共享内存获取模型信息结构体
	SMStruct sm = GetSMData();
	string name = sm.basicInfo._name;
	if (sm.basicInfo._id)
	{
		sm.basicInfo._health = health;
	}
	SetSMData(sm);
}

void ModelBase::SetType(int type)
{
	SMStruct sm = GetSMData();
	if (sm.basicInfo._id)
	{
		sm.basicInfo._type = type;
	}
	SetSMData(sm);
}

void ModelBase::SetHurt(double hurt)
{
	double health = GetHealth();
	if (health - hurt <= 0)
	{
		health = 0;
	}
	else
	{
		health = health - hurt;
	}
	SetHealth(health);
}

vector<EventBase*> ModelBase::HandleEvent()
{
	std::vector<EventBase*> ret = _eventsToSend;
	_eventsToSend.clear();
	return ret;
}

void ModelBase::HandleModelState()
{

}

void ModelBase::ReceiveEvent(EventBase *event)
{
	_events.push_back(event);
}

void ModelBase::Run(double t)
{
	//判断生命值，如果小于等于0，不执行
	if (GetHealth() <= 0)
	{
		return;
	}
	//在运行的基类里面,先执行所有组件的Run函数
	for (int i = 0; i < _myComponents.size(); i++)
	{
			_myComponents[i]->Run(t);
			//在这里通过组件的handleEvent函数读取组件产生的事件
			std::vector<EventBase*> events = _myComponents[i]->HandleEvent();
			for (int i = 0; i < events.size(); i++)
			{
				_eventsToSend.push_back(events[i]);
			}
	}
	//在Run完之后，根据组件类型获取相应数据
	//这一段不需要了，因为直接在共享内存里面修改
	/*for (int i = 0; i < _myComponents.size(); i++)
	{
		if (_myComponents[i]->_type == COM_MOVE)
		{
			_pos = _myComponents[i]->GetPos();
		}
	}*/
	//GetAllEventByID(std::vector<Message_Attack>& events,int id)
	//从服务获取自己所受的毁伤
	ServiceBase* service = _serviceInter->GetServiceByName("BattleAdjustService");
	if (service)
	{
		std::vector<Message_Attack> events;
		//service->GetAllEventByID(events, _id);//***在修改完共享内存后重写***
		if (events.size())
		{
			for (int i = 0; i < events.size(); i++)
			{
				SetHurt(events[i].attackRes._hurt);
				AttackResult result;
				result._agentID = events[i].attackRes._agentID;
				result._effectID = events[i].attackRes._effectID;
				result._category = events[i].attackRes._category;
				result._hurt = events[i].attackRes._hurt;
				//在这里推送事件到相应的实体
				Message_Attack* msg = new Message_Attack();
				msg->receicerID = result._effectID;
				msg->attackRes = result;
				_eventsToSend.push_back(msg);
			}
		}
	}
}

void ModelBase::Destory()
{
}

void ModelBase::GetBasicInfo(Model_BasicInfo &info)
{
	//***这里的获取基础数据在修改完共享内存后重写***
	/*info._id = _id;
	info._name = _name;
	info._type = _type;
	info._pos = _pos;
	info._shape = _shape;
	info._camp = _camp;
	info._health = _health;*/
}

void ModelBase::InitComponent()
{
	//读取类型对应配置文件名称
	int type = GetType();
	
	int t_Value = 0;
	std::string t_Name;

	TiXmlDocument* xmlDocument = new TiXmlDocument();
	if (!xmlDocument->LoadFile("data\\modelInfo\\model_enum.config"))
	{
		std::string err = xmlDocument->ErrorDesc();
	}
	TiXmlElement* rootElement = xmlDocument->FirstChildElement("Models");
	if (rootElement == nullptr) //节点不存在
	{
		delete xmlDocument;
		return ;
	}
	if (rootElement)
	{
		for (TiXmlElement* enumElement = rootElement->FirstChildElement("Enum");
			enumElement != nullptr; enumElement = enumElement->NextSiblingElement("Enum"))
		{
			for (TiXmlElement* valElement = enumElement->FirstChildElement();
				valElement != nullptr; valElement = valElement->NextSiblingElement())
			{
				std::string key = valElement->Value();
				if (key == "Value")
				{
					t_Value = atoi(valElement->FirstChild()->Value());
				}
				else if (key == "Name")
				{
					t_Name = valElement->FirstChild()->Value();
				}
			}
			if (t_Value == type)
			{
				break;
			}
		}
	}
	delete xmlDocument;
	//获取到了我应该读取哪个配置文件里面的动态库
	vector<string> libraryNameList;
	std::string configName = "data\\modelInfo\\ModelConfig\\" + t_Name + ".config";
	TiXmlDocument* xmlDocument1 = new TiXmlDocument();
	if (!xmlDocument1->LoadFile(configName.c_str()))
	{
		std::string err = xmlDocument1->ErrorDesc();
	}
	TiXmlElement* rootElement1 = xmlDocument1->FirstChildElement("Model");
	if (rootElement1 == nullptr) //节点不存在
	{
		delete xmlDocument1;
		return ;
	}
	if (rootElement1)
	{
		TiXmlElement* componentElement = rootElement1->FirstChildElement("Components");
		if (componentElement)
		{
			for (TiXmlElement* enumElement = componentElement->FirstChildElement("Component");
				enumElement != nullptr; enumElement = enumElement->NextSiblingElement("Component"))
			{
				for (TiXmlElement* valElement = enumElement->FirstChildElement();
					valElement != nullptr; valElement = valElement->NextSiblingElement())
				{
					std::string key = valElement->Value();
					if (key == "Library")
					{
						libraryNameList.push_back(valElement->FirstChild()->Value());
					}
				}
			}
		}
	}
	delete xmlDocument1;
	//导入组件列表
	for (int i = 0; i < libraryNameList.size(); i++)
	{
		HINSTANCE hDll;
		#if _DEBUG
		std::string dllPath = "dll\\Debug\\" + libraryNameList[i] + "d.dll";
		hDll = LoadLibrary(stringToLPCWSTR(dllPath));
		#endif
		#if NDEBUG
		std::string dllPath = "dll\\Release\\" + libraryNameList[i] + ".dll";
		hDll = LoadLibrary(stringToLPCWSTR(dllPath));
		#endif
		if (hDll == NULL)
		{
			std::cout << "Load dll failed!";
			return;
		}
		using functionPtr = ComponentBase * (*)();
		functionPtr addFunction = (functionPtr)GetProcAddress(hDll, "CreateComponent");
		if (addFunction == NULL)
		{
			std::cout << "cannot find target function!";
			return ;
		}
		ComponentBase* com = addFunction();
		com->SetServiceInterface(_serviceInter);
		com->Init(nullptr);
		com->ReadScenario();
		Model_BasicInfo info;
		GetBasicInfo(info);
		com->SetBasicInfo(info);
		_myComponents.push_back(com);
	}
}

void ModelBase::PutEventToComponent()
{
	for (int i = 0; i < _myComponents.size(); i++)
	{
		for (int j = 0; j < _events.size(); j++)
		{
			_myComponents[i]->ReceiveEvent(_events[j]);
		}
	}
	_events.clear();
}

void ModelBase::SetServiceInterFace()
{
	_serviceInter = ServiceInterface::GetInstance();
	if (_serviceInter)
	{
		int i = 0;
	}
}

void ModelBase::CreateSmData(SMStruct sm)
{
	std::wstring wideStr(_shareMemoryID.begin(), _shareMemoryID.end());
	LPCWSTR lpcwstr = wideStr.c_str();
	hMapFile = CreateFileMapping(
		INVALID_HANDLE_VALUE,    // 使用分页文件
		NULL,                    // 默认安全属性
		PAGE_READWRITE,          // 读写权限
		0,                       // 高序DWORD的文件映射大小
		sizeof(SMStruct),      // 低序DWORD的文件映射大小
		lpcwstr); // 共享内存名称

	if (hMapFile == NULL) {
		std::cerr << "CreateFileMapping failed: " << GetLastError() << std::endl;//***错误后面写道log服务里
		return ;
	}

	pData = (SMStruct*)MapViewOfFile(
		hMapFile,                // 映射对象句柄
		FILE_MAP_ALL_ACCESS,     // 读写权限
		0,
		0,
		sizeof(SMStruct));

	if (pData == NULL) {
		std::cerr << "MapViewOfFile failed: " << GetLastError() << std::endl;//***错误后面写道log服务里
		CloseHandle(hMapFile);
		return ;
	}
	pData->basicInfo = sm.basicInfo;
	pData->otherInfo = sm.otherInfo;
}

SMStruct ModelBase::GetSMData()
{
	SMStruct sm;
	if (hMapFile && pData)
	{
		sm.basicInfo = pData->basicInfo;
		sm.otherInfo = pData->otherInfo;
	}
	return sm;
}

void ModelBase::SetSMData(SMStruct sm)
{
	*pData = sm;
}

double ModelBase::GetHealth()
{
	return  GetSMData().basicInfo._health;
}

Model_Position ModelBase::GetPos()
{
	return GetSMData().basicInfo._pos;
}

int ModelBase::GetType()
{
	return GetSMData().basicInfo._type;
}